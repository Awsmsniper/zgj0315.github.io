#+TITLE: maven构建es java工程
* 概述
折腾了几天ES的Java API，中间最为周折的就时maven打包jar时出的问题，各种查问题，各种查不到，整整折腾了我24小时，最后看了看官方文档，日了狗了，居然那么简单。

* 开发环境
| 软件          | 版本                                          |
|---------------+-----------------------------------------------|
| 操作系统      | Mac OS X EI Capitan                           |
|---------------+-----------------------------------------------|
| JDK           | 1.8.0_91                                      |
|---------------+-----------------------------------------------|
| eclipse       | clipse-java-mars-2-macosx-cocoa-x86_64.tar.gz |
|---------------+-----------------------------------------------|
| ElasticSearch | 2.3.1                                         |

* 创建工程
打开eclipse，创建一个Maven Project，采用maven-archetype-quickstart 1.1作为模版。

创建好工程后修改两个地方：
1. Java Build Path中的JRE选为1.8的
2. Java Compiler中的Compiler compliance level:选为1.8（不然override都会警告）

* pom.xml
这个配置文件按照其它java工程的方式，出现了lunce的包打不进去的各种异常，报错如下：
#+BEGIN_SRC
Exception in thread "main" TransportSerializationException[Failed to deserialize response of type [org.elasticsearch.action.search.SearchResponse]]; nested: ExceptionInInitializerError; nested: IllegalArgumentException[An SPI class of type org.apache.lucene.codecs.PostingsFormat with name 'Lucene50' does not exist.  You need to add the corresponding JAR file supporting this SPI to your classpath.  The current classpath supports the following names: [es090, completion090, XBloomFilter]];
	at org.elasticsearch.transport.netty.MessageChannelHandler.handleResponse(MessageChannelHandler.java:180)
	at org.elasticsearch.transport.netty.MessageChannelHandler.messageReceived(MessageChannelHandler.java:138)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:296)
	at org.jboss.netty.handler.codec.frame.FrameDecoder.unfoldAndFireMessageReceived(FrameDecoder.java:462)
	at org.jboss.netty.handler.codec.frame.FrameDecoder.callDecode(FrameDecoder.java:443)
	at org.jboss.netty.handler.codec.frame.FrameDecoder.messageReceived(FrameDecoder.java:303)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)
	at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:268)
	at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:255)
	at org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:88)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.process(AbstractNioWorker.java:108)
	at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:337)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:89)
	at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178)
	at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:108)
	at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.ExceptionInInitializerError
	at org.elasticsearch.search.internal.InternalSearchHit.readFrom(InternalSearchHit.java:573)
	at org.elasticsearch.search.internal.InternalSearchHit.readSearchHit(InternalSearchHit.java:553)
	at org.elasticsearch.search.internal.InternalSearchHits.readFrom(InternalSearchHits.java:225)
	at org.elasticsearch.search.internal.InternalSearchHits.readFrom(InternalSearchHits.java:205)
	at org.elasticsearch.search.internal.InternalSearchHits.readSearchHits(InternalSearchHits.java:199)
	at org.elasticsearch.search.internal.InternalSearchResponse.readFrom(InternalSearchResponse.java:132)
	at org.elasticsearch.search.internal.InternalSearchResponse.readInternalSearchResponse(InternalSearchResponse.java:126)
	at org.elasticsearch.action.search.SearchResponse.readFrom(SearchResponse.java:202)
	at org.elasticsearch.transport.netty.MessageChannelHandler.handleResponse(MessageChannelHandler.java:178)
	... 23 more
Caused by: java.lang.IllegalArgumentException: An SPI class of type org.apache.lucene.codecs.PostingsFormat with name 'Lucene50' does not exist.  You need to add the corresponding JAR file supporting this SPI to your classpath.  The current classpath supports the following names: [es090, completion090, XBloomFilter]
	at org.apache.lucene.util.NamedSPILoader.lookup(NamedSPILoader.java:114)
	at org.apache.lucene.codecs.PostingsFormat.forName(PostingsFormat.java:112)
	at org.elasticsearch.common.lucene.Lucene.<clinit>(Lucene.java:65)
	... 32 more
#+END_SRC

eclipse里直接执行代码，完全正确的情况下，打包成jar，就傻逼了，报以上的错误信息。

你按照网上查到的说jdk版本问题的路子解决，反正我是没搞定。

解决办法是用下面的pom文件配置：
#+BEGIN_SRC
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.qzt360</groupId>
	<artifactId>es</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>es</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.elasticsearch</groupId>
			<artifactId>elasticsearch</artifactId>
			<version>2.3.1</version>
		</dependency>
		<dependency>
			<groupId>log4j</groupId>
			<artifactId>log4j</artifactId>
			<version>1.2.17</version>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
	<build>
		<plugins>
			<!-- create a single jar containing your application and all dependencies -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-shade-plugin</artifactId>
				<version>2.4.1</version>
				<executions>
					<execution>
						<phase>package</phase>
						<goals>
							<goal>shade</goal>
						</goals>
						<configuration>
							<transformers>
								<transformer
									implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer" />
								<!-- if you have a main class you want to automatically call when 
									running java -jar yourjar.jar -->
								<transformer
									implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
									<mainClass>com.qzt360.ESWJLog.QueryFromImLog</mainClass>
								</transformer>
							</transformers>
						</configuration>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>
</project>

#+END_SRC

* 代码例子
#+BEGIN_SRC
package com.qzt360.es;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.log4j.Logger;
import org.elasticsearch.action.admin.indices.template.put.PutIndexTemplateRequest;
import org.elasticsearch.action.bulk.BulkProcessor;
import org.elasticsearch.action.bulk.BulkRequest;
import org.elasticsearch.action.bulk.BulkRequestBuilder;
import org.elasticsearch.action.bulk.BulkResponse;
import org.elasticsearch.action.delete.DeleteResponse;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.action.get.MultiGetItemResponse;
import org.elasticsearch.action.get.MultiGetResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.search.SearchType;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.client.Client;
import org.elasticsearch.client.IndicesAdminClient;
import org.elasticsearch.client.transport.TransportClient;
import org.elasticsearch.common.collect.MapBuilder;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.transport.InetSocketTransportAddress;
import org.elasticsearch.common.unit.ByteSizeUnit;
import org.elasticsearch.common.unit.ByteSizeValue;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.index.query.WildcardQueryBuilder;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;

public class ESManager {
	private String strClusterName;
	private String strTransportHostName;
	private int nConcurrentRequests = 8;// 貌似是单机cpu核心数时速度最佳
	private Logger logger = Logger.getLogger(ESManager.class);

	public Client client = null;
	public BulkProcessor bulkProcessor = null;

	public ESManager() {
		super();
	}

	public ESManager(String strClusterName, String strTransportHostName) {
		super();
		this.strClusterName = strClusterName;
		this.strTransportHostName = strTransportHostName;
	}

	public ESManager(String strClusterName, String strTransportHostName, int nConcurrentRequests) {
		super();
		this.strClusterName = strClusterName;
		this.strTransportHostName = strTransportHostName;
		this.nConcurrentRequests = nConcurrentRequests;
	}

	public static void main(String[] args) {

		// 批量入库
		// client.prepareIndex("index_01", "type_01").get();
		// for (int i = 0; i < 10; i++) {
		// Map<String, Object> json = new HashMap<String, Object>();
		// json.put("title", "user" + i);
		// json.put("date_create", new Date());
		// json.put("context", "trying out Elasticsearch" + i);
		// // update(json, strIndex, strType, "im_20160303_0");
		// bulkProcessor.add(new IndexRequest(strIndex, strType, "id_" +
		// i).source(json));
		// }
		// 查询
		// QueryBuilder qb1 = QueryBuilders.termQuery("user", "user8");
		// QueryBuilder qb2 = QueryBuilders.matchQuery("user", "user8");
		// // QueryBuilder qb2 = QueryBuilders.fil
		// QueryBuilder qb3 =
		// QueryBuilders.boolQuery().must(QueryBuilders.termQuery("user",
		// "user1"));
		// // .must(QueryBuilders.termQuery("user", "user2"));
		// // .mustNot(QueryBuilders.termQuery("user", "user3"))
		// // .mustNot(QueryBuilders.termQuery("user",
		// // "user4")).should(QueryBuilders.termQuery("user", "user5"));
		// QueryBuilder qb4 = QueryBuilders.filteredQuery(qb1,
		// QueryBuilders.rangeQuery("age").from(20).to(30).includeLower(true).includeUpper(false));
		//
		// WildcardQueryBuilder wqb = new WildcardQueryBuilder("user", "*ser*");
		// QueryBuilder qb5 = QueryBuilders.boolQuery().should(wqb);
		// QueryBuilder qb6 = QueryBuilders.boolQuery().must(wqb);
		// SearchResponse response =
		// client.prepareSearch(strIndex).setTypes(strType)
		// .setSearchType(SearchType.DFS_QUERY_THEN_FETCH).setQuery(qb6).setFrom(0).setSize(100).setExplain(true)
		// .execute().actionGet();
		//
		// for (SearchHit hit : response.getHits()) {
		// Map<String, Object> source = hit.getSource();
		// // logger.info("user: " + source.get("user"));
		// logger.info("source: " + source.toString());
		// }
		// WildcardQueryBuilder wqb = new WildcardQueryBuilder("title", "*se*");
		// QueryBuilder qb = QueryBuilders.boolQuery().should(wqb);
		// SearchResponse response =
		// client.prepareSearch(strIndex).setTypes(strType)
		// .setSearchType(SearchType.DFS_QUERY_THEN_FETCH).setQuery(qb).setFrom(0).setSize(100).setExplain(true)
		// .execute().actionGet();
		//
		// for (SearchHit hit : response.getHits()) {
		// Map<String, Object> source = hit.getSource();
		// // logger.info("user: " + source.get("user"));
		// logger.info("source: " + source.toString());
		// }
		// cleanup();
	}

	private void admin(IndicesAdminClient iac) {
		// 定义IM数据模版
		PutIndexTemplateRequest pitr = new PutIndexTemplateRequest("im").template("im*");
		// setting
		// pitr.settings(new MapBuilder<String,
		// Object>().put("number_of_shards", 6).put("number_of_replicas", 1)
		// .put("refresh_interval", "1s").put("merge.policy.floor_segment",
		// "2mb").map());

		Map<String, Object> defaultMapping = new HashMap<String, Object>();
		// 关闭_all
		defaultMapping.put("_all", new MapBuilder<String, Object>().put("enabled", false).map());
		defaultMapping.put("numeric_detection", false);
		defaultMapping.put("dynamic_templates", new Object[] {
				new MapBuilder<String, Object>()
						.put("date_tpl", new MapBuilder<String, Object>().put("match", "date*")
								.put("mapping",
										new MapBuilder<String, Object>().put("type", "date")
												.put("index", "not_analyzed").put("doc_values", true).map())
								.map())
						.map(),
				new MapBuilder<String, Object>()
						.put("all_tpl", new MapBuilder<String, Object>().put("match", "*")
								.put("mapping",
										new MapBuilder<String, Object>().put("type", "{dynamic_type}")
												.put("index", "not_analyzed").put("doc_values", true).map())
								.map())
						.map() });
		pitr.mapping("_default_", defaultMapping);
		iac.putTemplate(pitr);
	}

	private static Lock initLock = new ReentrantLock();

	public void setup() {
		logger.debug("init settings");
		if (client == null) {
			initLock.lock();
			Settings settings;
			if (strClusterName == null) {
				settings = Settings.settingsBuilder().put("cluster.name", "qzt360esmacbookpro")
						.put("client.transport.sniff", true).build();
			} else {
				settings = Settings.settingsBuilder().put("cluster.name", strClusterName)
						.put("client.transport.sniff", true).build();
			}
			try {
				logger.debug("init client");
				if (strTransportHostName == null) {
					client = TransportClient.builder().settings(settings).build().addTransportAddress(
							new InetSocketTransportAddress(InetAddress.getByName("localhost"), 9300));
				} else {
					client = TransportClient.builder().settings(settings).build().addTransportAddress(
							new InetSocketTransportAddress(InetAddress.getByName(strTransportHostName), 9300));
				}
				IndicesAdminClient iac = client.admin().indices();
				admin(iac);
			} catch (UnknownHostException e) {
				logger.error(e);
			} finally {
				initLock.unlock();
			}
		}
		if (bulkProcessor == null) {
			bulkProcessor = BulkProcessor.builder(client, new BulkProcessor.Listener() {
				@Override
				public void beforeBulk(long executionId, BulkRequest request) {
				}

				@Override
				public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {
				}

				@Override
				public void afterBulk(long executionId, BulkRequest request, Throwable failure) {
				}
			}).setBulkActions(5000).setBulkSize(new ByteSizeValue(10, ByteSizeUnit.MB))
					.setFlushInterval(TimeValue.timeValueSeconds(5)).setConcurrentRequests(nConcurrentRequests).build();
		}
	}

	// 删除某个索引
	public void deleteIndex(String strIndex) {
		if (client.admin().indices().prepareExists(strIndex).get().isExists()) {
			client.admin().indices().prepareDelete(strIndex).get();
		}
	}

	// 创建一个空索引，很少用到这种情况
	public void createIndex(String strIndex) {
		if (!client.admin().indices().prepareExists(strIndex).get().isExists()) {
			client.admin().indices().prepareCreate(strIndex).get();
		}
	}

	public void cleanup() {
		logger.debug("bulkProcessor close");
		if (bulkProcessor != null) {
			try {
				bulkProcessor.awaitClose(10, TimeUnit.SECONDS);
			} catch (InterruptedException e) {
				logger.error(e);
			}
		}
		logger.debug("client close");
		if (client != null) {
			client.close();
		}
	}

	// 保存数据，insert 返回ture，update 返回false
	public boolean save(Map<String, Object> json, String strIndex, String strType, String strId) {
		UpdateResponse resp = client.update(new UpdateRequest(strIndex, strType, strId).doc(json).upsert(json))
				.actionGet();
		if (resp.isCreated()) {
			return true;
		} else {
			return false;
		}
	}

	public boolean update(Map<String, Object> json, String index, String type, String id) {

		UpdateResponse resp = client.update(new UpdateRequest(index, type, id).doc(json).upsert(json)).actionGet();
		if (resp.isCreated())
			return true;
		return false;
	}

	public void index(Map<String, Object> json, String strIndex, String strType) {
		// logger.debug("json init");
		// Map<String, Object> json = new HashMap<String, Object>();
		// json.put("user", "kimchy");
		// json.put("postDate", new Date());
		// json.put("message", "trying out Elasticsearch");
		logger.debug("response init");
		// IndexResponse response =
		client.prepareIndex(strIndex, strType).setSource(json).get();

		// logger.debug("index:" + response.getIndex());
		// logger.debug("type:" + response.getType());
		// logger.debug("id:" + response.getId());
		// logger.debug("version:" + response.getVersion());
		// logger.debug("isCreated:" + response.isCreated());
	}

	public void index(Map<String, Object> json, String strIndex, String strType, String strId) {
		// logger.debug("json init");
		// Map<String, Object> json = new HashMap<String, Object>();
		// json.put("user", "kimchy");
		// json.put("postDate", new Date());
		// json.put("message", "trying out Elasticsearch");
		logger.debug("response init");
		// IndexResponse response =
		client.prepareIndex(strIndex, strType, strId).setSource(json).get();
		// logger.debug("index:" + response.getIndex());
		// logger.debug("type:" + response.getType());
		// logger.debug("id:" + response.getId());
		// logger.debug("version:" + response.getVersion());
		// logger.debug("isCreated:" + response.isCreated());
	}

	public void get() {
		logger.debug("GetResponse init");
		GetResponse response = client.prepareGet("twitter", "tweet", "1").get();
		logger.debug("index:" + response.getIndex());
		logger.debug("type:" + response.getType());
		logger.debug("id:" + response.getId());
		logger.debug("version:" + response.getVersion());
	}

	public void delete() {
		logger.debug("DeleteResponse init");
		DeleteResponse response = client.prepareDelete("twitter", "tweet", "1").get();
		logger.debug("index:" + response.getIndex());
		logger.debug("type:" + response.getType());
		logger.debug("id:" + response.getId());
		logger.debug("version:" + response.getVersion());
	}

	public void update() {

	}

	public void search() {
		// SearchResponse response = client.prepareSearch("twitter",
		// "tweet").setTypes("type1", "type2")
		// .setSearchType(SearchType.DFS_QUERY_THEN_FETCH).setQuery(QueryBuilders.termQuery("multi",
		// "test")) // Query
		// .setPostFilter(QueryBuilders.rangeQuery("age").from(12).to(18)) //
		// Filter
		// .setFrom(0).setSize(60).setExplain(true).execute().actionGet();
		// MatchAll on the whole cluster with all default options
		// SearchResponse responseAll =
		// client.prepareSearch().execute().actionGet();
		// logger.debug("contextSize:" + responseAll.contextSize());
		// logger.debug("toString:" + responseAll.toString());
		// logger.debug("getContext().size:" + responseAll.getContext().size());
		QueryBuilder qb1 = QueryBuilders.termQuery("strCallerId", "522738778");
		SearchResponse response = client.prepareSearch("im_20160303", "im_20160304").setTypes("im")
				.setSearchType(SearchType.DFS_QUERY_THEN_FETCH).setQuery(qb1).setFrom(0).setSize(60).setExplain(true)
				.execute().actionGet();
		SearchHits hits = response.getHits();
		for (int i = 0; i < 60; i++) {
			logger.info("" + hits.getAt(i).getScore());
		}
	}

	public void search(String strNetid) {
		setup();
		WildcardQueryBuilder wqb = new WildcardQueryBuilder("strCallerId", "*" + strNetid + "*");
		QueryBuilder qb = QueryBuilders.boolQuery().should(wqb);
		SearchResponse response = client.prepareSearch("im_20160303").setTypes("im")
				.setSearchType(SearchType.DFS_QUERY_THEN_FETCH).setQuery(qb).setFrom(0).setSize(100).setExplain(true)
				.execute().actionGet();

		for (SearchHit hit : response.getHits()) {
			Map<String, Object> source = hit.getSource();
			// logger.info("user: " + source.get("user"));
			logger.info("source: " + source.toString());
		}
		cleanup();
	}

	public void multiGet() {
		MultiGetResponse multiGetItemResponses = client.prepareMultiGet().add("twitter", "tweet", "1")
				.add("twitter", "tweet", "2", "3", "4").add("another", "type", "foo").get();

		for (MultiGetItemResponse itemResponse : multiGetItemResponses) {
			GetResponse response = itemResponse.getResponse();
			if (response.isExists()) {
				String json = response.getSourceAsString();
				logger.debug(json);
			}
		}
	}

	public void bulk(List<Map<String, Object>> listJson, String strIndex, String strType) {
		logger.debug("BulkRequestBuilder init");
		BulkRequestBuilder bulkRequest = client.prepareBulk();
		for (Map<String, Object> json : listJson) {
			bulkRequest.add(client.prepareIndex(strIndex, strType).setSource(json));
		}
		BulkResponse bulkResponse = bulkRequest.get();
		if (bulkResponse.hasFailures()) {
			logger.debug("bulkResponse.hasFailures():true");
		} else {
			logger.debug("bulkResponse.hasFailures():false");
		}
	}

	public void bulkProcessor(List<Map<String, Object>> listJson, String strIndex, String strType) {
		for (Map<String, Object> json : listJson) {
			bulkProcessor.add(new IndexRequest(strIndex, strType).source(json));
		}
	}

	public void bulkProcessor(Map<String, Object> json, String strIndex, String strType) {
		bulkProcessor.add(new IndexRequest(strIndex, strType).source(json));
	}

	public void bulkProcessor(List<Map<String, Object>> listJson, String strIndex, String strType, String strIdKey) {
		for (Map<String, Object> json : listJson) {
			bulkProcessor.add(new IndexRequest(strIndex, strType, (String) json.get(strIdKey)).source(json));
		}
	}

	public static void count() {

	}

	public static void query() {

	}
}

#+END_SRC

#+BEGIN_SRC
package com.qzt360.ESWJLog;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;
import org.elasticsearch.action.index.IndexRequest;

public class ImLog2ES {
	private static Logger logger = Logger.getLogger(ImLog2ES.class);

	public static void main(String[] args) {
		logger.debug("ImLog2ES begin");

		ESManager esm = new ESManager("wj-es", "192.168.36.31", Integer.parseInt(args[1]));
		esm.setup();
		File filePath = new File(args[0]);
		File[] aFile = filePath.listFiles();

		long lBegin = System.currentTimeMillis();
		BufferedReader br = null;
		String strLine = null;
		int nRow = 0;
		IMManager im = new IMManager();
		try {
			for (File file : aFile) {
				br = new BufferedReader(new InputStreamReader(new FileInputStream(file.getPath())));
				while ((strLine = br.readLine()) != null) {
					nRow++;
					if (im.isLegal(strLine)) {
						Map<String, Object> json = new HashMap<String, Object>();
						json.put("nCustomerId", im.getnCustomerId());
						json.put("nDeptId", im.getnDeptId());
						json.put("strHostName", im.getStrHostName());
						json.put("strEqpName", im.getStrEqpName());
						json.put("dateTime", new Date((long) im.getnTime() * 1000L));
						json.put("lSip", im.getlSip());
						json.put("strSmac", im.getStrSmac());
						json.put("nApplication", im.getnApplication());
						json.put("nType", im.getnType());
						json.put("lSessionId", im.getlSessionId());
						json.put("strCallerId", im.getStrCallerId());
						json.put("strCalledId", im.getStrCalledId());
						json.put("nDir", im.getnDir());
						json.put("nContentLen", im.getnContentLen());
						json.put("strContent", im.getStrContent());
						json.put("nPartyNum", im.getnPartyNum());
						json.put("strCallerNickname", im.getStrCallerNickname());
						json.put("strCalledNickname", im.getStrCalledNickname());
						json.put("nCertType", im.getnCertType());
						json.put("strCertCode", im.getStrCertCode());
						json.put("strName", im.getStrName());
						json.put("strCountryCode", im.getStrCountryCode());
						esm.bulkProcessor
								.add(new IndexRequest("im", file.getName(), file.getName() + "_" + nRow).source(json));
					}
				}
			}
		} catch (Exception e) {
			logger.error(e);
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
					logger.error(e);
				}
			}
		}
		long lEnd = System.currentTimeMillis();
		esm.cleanup();
		logger.info("time: " + (lEnd - lBegin));
		logger.debug("ImLog2ES end");
	}

}

#+END_SRC

#+BEGIN_SRC
package com.qzt360.ESWJLog;

import java.util.Map;

import org.apache.log4j.Logger;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.search.SearchType;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.index.query.WildcardQueryBuilder;
import org.elasticsearch.search.SearchHit;

public class QueryFromImLog {
	private static Logger logger = Logger.getLogger(QueryFromImLog.class);

	public static void main(String[] args) {
		if (args.length != 5) {
			System.out.println("<indexs> <types> <field> <like or notlike> <account>");
			System.exit(5);
		}
		String[] astrIndex = args[0].split(",");
		String[] astrType = args[1].split(",");
		logger.debug("QueryFromImLog begin");
		ESManager esm = new ESManager("wj-es", "192.168.36.31");
		esm.setup();
		long lBegin = System.currentTimeMillis();

		QueryBuilder qb = QueryBuilders.boolQuery().must(QueryBuilders.termQuery(args[2], args[4]));
		if ("like".equals(args[3])) {
			WildcardQueryBuilder wqb = new WildcardQueryBuilder(args[2], "*" + args[4] + "*");
			qb = QueryBuilders.boolQuery().should(wqb);
		}

		SearchResponse response = esm.client.prepareSearch(astrIndex).setTypes(astrType)
				.setSearchType(SearchType.DFS_QUERY_THEN_FETCH).setQuery(qb).setFrom(0).setSize(100).setExplain(true)
				.execute().actionGet();

		for (SearchHit hit : response.getHits()) {
			Map<String, Object> source = hit.getSource();
			logger.info("source: " + source.toString());
		}
		long lEnd = System.currentTimeMillis();
		esm.cleanup();
		logger.info("time: " + (lEnd - lBegin));
		logger.debug("QueryFromImLog end");
	}

}

#+END_SRC
